\section{主要算法}
    \subsection{缓冲区页面置换算法}
        使用LRU算法。利用一个哈希表和一个链表模拟一个元素不重复栈，%
        栈具有固定大小，超出设定的大小时舍弃栈底数据。

        当访问某个页面时，先在哈希表中搜索，%
        若未搜索到，说明该页不在缓冲区中，读取该页并将页号放在链表头（栈顶），%
        在哈希表中插入该页页号和链表的指针；%
        若在哈希表中搜索到，则将链表中的节点移动到链表头，并更新哈希表。%
        如此可在渐进$O(1)$时间内根据页号返回页数据。
    \subsection{B+树索引}
        B+树是经典算法，在此不再赘述。
    \subsection{多表连接}
        递归地向一个栈中加入RID，栈底是第一个表的RID，%
        上面依次是第二个、第三个\dots\dots%
        每次加入一个数据，若不满足条件则回溯，%
        直到栈大小等于要连接的表的个数，则得到一条连接记录。
    \subsection{分组聚集查询}
        先对待分组的结果排序，之后去重，%
        对于重复的记录若有聚集函数则使用聚集函数返回值代替原值。
    \subsection{模糊匹配}
        将存储类型转化为显示数据（如将二进制整型和浮点型转换为十进制），%
        再用正则表达式匹配。
    \subsection{实体完整性约束}
        每次向表中插入或修改数据时，检查若发现主键重复或主键为空则拒绝此次操作。%
        对于无主键表，为实现方便创建一个隐藏的主键，%
        其键值为插入此记录时的纳秒级时间，%
        对于现代CPU体系结构而言，可以保证任意两条记录主键值不同。
    \subsection{域完整性约束}
        每次插入或修改记录时检查是否满足域完整性约束，若不满足则拒绝此次操作。
    \subsection{参照完整性约束}
        修改或删除主表主键时，检查该键值是否被引用，若被引用则拒绝修改或删除。

        插入或修改从表时，检查主表是否存在此键值，若不存在则拒绝插入或修改。
    \subsection{出错回滚}
        对于单条语句插入多条记录，UPDATE语句，%
        为保证操作的原子性，运行过程中出错需要回滚。%
        
        在操作过程中，将每一个成功的操作压入栈中，若某次操作失败，%
        则依次取出栈中的操作进行回滚。

